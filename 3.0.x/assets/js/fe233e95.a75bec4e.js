"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[1183],{3873:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>a,toc:()=>c});var i=t(4848),r=t(8453);const s={},o=void 0,a={id:"Tutorials/Fragments/Fragments/VisibilityOperations",title:"VisibilityOperations",description:'window.open("https://thatopen.github.io/engine_fragment/examples/VisibilityOperations")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/VisibilityOperations.mdx",sourceDirName:"Tutorials/Fragments/Fragments",slug:"/Tutorials/Fragments/Fragments/VisibilityOperations",permalink:"/engine_past-docs/3.0.x/Tutorials/Fragments/Fragments/VisibilityOperations",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Raycasting",permalink:"/engine_past-docs/3.0.x/Tutorials/Fragments/Fragments/Raycasting"},next:{title:"UserInterface",permalink:"/engine_past-docs/3.0.x/Tutorials/UserInterface/"}},l={},c=[{value:"Managing Your Fragments Visibility \ud83d\udc40",id:"managing-your-fragments-visibility-",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading a Fragments Model",id:"-loading-a-fragments-model",level:3},{value:"\u274e Hiding",id:"-hiding",level:3},{value:"\ud83d\udd04 Toggling",id:"-toggling",level:3},{value:"\ud83d\udc41\ufe0f Getting Current Visibility",id:"\ufe0f-getting-current-visibility",level:3},{value:"\ud83e\udde9 Adding User Interface (optional)",id:"-adding-user-interface-optional",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{style:{position:"relative"},children:[(0,i.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/VisibilityOperations"}),(0,i.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/VisibilityOperations"),children:"Go Full Screen"})]}),"\n",(0,i.jsx)(n.admonition,{title:"Source",type:"info",children:(0,i.jsxs)(n.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,i.jsx)(n.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/a3f91db6422f752fd5dc26532d6cf29eb989b677/packages/fragments/src/FragmentsModels/samples/VisibilityOperations/example.ts",children:"here"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"managing-your-fragments-visibility-",children:"Managing Your Fragments Visibility \ud83d\udc40"}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.p,{children:"Managing visibility\u2014whether it's hiding, showing, or toggling\u2014is a fundamental feature in any 3D application. In this tutorial, you'll learn how to effectively manage the visibility of your Fragments models!"}),"\n",(0,i.jsx)(n.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,i.jsx)(n.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'import * as OBC from "@thatopen/components";\r\nimport * as BUI from "@thatopen/ui";\r\nimport Stats from "stats.js";\r\n// You have to import * as FRAGS from "@thatopen/fragments"\r\nimport * as FRAGS from "../../..";\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,i.jsx)(n.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const components = new OBC.Components();\r\n\r\nconst worlds = components.get(OBC.Worlds);\r\nconst world = worlds.create<\r\n  OBC.SimpleScene,\r\n  OBC.SimpleCamera,\r\n  OBC.SimpleRenderer\r\n>();\r\n\r\nworld.scene = new OBC.SimpleScene(components);\r\nworld.scene.setup();\r\nworld.scene.three.background = null;\r\n\r\nconst container = document.getElementById("container")!;\r\nworld.renderer = new OBC.SimpleRenderer(components, container);\r\n\r\nworld.camera = new OBC.SimpleCamera(components);\r\nworld.camera.controls.setLookAt(183, 11, -102, 27, -52, -11); // convenient position for the model we will load\r\n\r\ncomponents.init();\r\n\r\nconst grids = components.get(OBC.Grids);\r\ngrids.create(world);\n'})}),"\n",(0,i.jsx)(n.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,i.jsx)(n.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,i.jsx)(n.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'// You can copy `/node_modules/@thatopen/fragments/dist/Worker/worker.mjs` to your project directory\r\n// and provide the relative path of the worker, or fetch it from github, unpkg, etc.\r\nconst workerUrl =\r\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\r\nconst fetchedWorker = await fetch(workerUrl);\r\nconst workerText = await fetchedWorker.text();\r\nconst workerFile = new File([new Blob([workerText])], "worker.mjs", {\r\n  type: "text/javascript",\r\n});\r\nconst url = URL.createObjectURL(workerFile);\r\nconst fragments = new FRAGS.FragmentsModels(url);\r\nworld.camera.controls.addEventListener("rest", () => fragments.update(true));\r\nworld.camera.controls.addEventListener("update", () => fragments.update());\r\n\r\n// Once a model is available in the list, we can tell what camera to use\r\n// in order to perform the culling and LOD operations.\r\n// Also, we add the model to the 3D scene.\r\nfragments.models.list.onItemSet.add(({ value: model }) => {\r\n  model.useCamera(world.camera.three);\r\n  world.scene.three.add(model.object);\r\n  // At the end, you tell fragments to update so the model can be seen given\r\n  // the initial camera position\r\n  fragments.update(true);\r\n});\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-loading-a-fragments-model",children:"\ud83d\udcc2 Loading a Fragments Model"}),"\n",(0,i.jsx)(n.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,i.jsx)(n.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,i.jsx)(n.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const file = await fetch("https://thatopen.github.io/engine_fragment/resources/frags/school_arq.frag");\r\nconst buffer = await file.arrayBuffer();\r\nconst model = await fragments.load(buffer, { modelId: "example" });\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-hiding",children:"\u274e Hiding"}),"\n",(0,i.jsxs)(n.p,{children:["Hiding specific items in the model can be crucial for focusing on certain elements or decluttering the view. Here's how you can easily hide all ",(0,i.jsx)(n.code,{children:"IfcRoof"})," elements immediately after the model has been loaded:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const roofs = await model.getItemsOfCategory("IFCROOF");\r\nconst spaceLocalIds = (\r\n  await Promise.all(roofs.map((space) => space.getLocalId()))\r\n).filter((localId) => typeof localId !== "undefined") as number[];\r\n\r\nawait model.setVisible(spaceLocalIds, false);\r\nawait fragments.update(true);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-toggling",children:"\ud83d\udd04 Toggling"}),"\n",(0,i.jsx)(n.p,{children:"Toggling the visibility of items is a common requirement in 3D applications. To make this functionality reusable and efficient, let's create a function that toggles the visibility of items based on their category:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const toggleVisibilityByCategory = async (category: string) => {\r\n  const items = await model.getItemsOfCategory(category);\r\n  const localIds = (\r\n    await Promise.all(items.map((wall) => wall.getLocalId()))\r\n  ).filter((localId) => typeof localId !== "undefined") as number[];\r\n  await model.toggleVisible(localIds);\r\n  await fragments.update(true);\r\n};\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-getting-current-visibility",children:"\ud83d\udc41\ufe0f Getting Current Visibility"}),"\n",(0,i.jsx)(n.p,{children:"Knowing whether an item is visible or not can be crucial for various operations, such as displaying the names of visible items only. Here's a function to retrieve the visibility status of items based on their category:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const getVisibilityByCategory = async (category: string) => {\r\n  const items = await model.getItemsOfCategory(category);\r\n  const localIds = (\r\n    await Promise.all(items.map((wall) => wall.getLocalId()))\r\n  ).filter((localId) => localId !== null) as number[];\r\n  const result = await model.getVisible(localIds);\r\n  const count = result.reduce(\r\n    (acc, isVisible) => {\r\n      if (isVisible) {\r\n        acc.visible++;\r\n      } else {\r\n        acc.hidden++;\r\n      }\r\n      return acc;\r\n    },\r\n    { visible: 0, hidden: 0 },\r\n  );\r\n  return count;\r\n};\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In addition to the above, you can retrieve a list of ",(0,i.jsx)(n.code,{children:"localIds"})," for all visible or hidden items in the entire model. Here's a function to get the count of visible and hidden elements efficiently:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const getVisibilityCount = async () => {\r\n  const visible = await model.getItemsByVisibility(true);\r\n  const hidden = await model.getItemsByVisibility(false);\r\n  return { visible: visible.length, hidden: hidden.length };\r\n};\n"})}),"\n",(0,i.jsx)(n.h3,{id:"-adding-user-interface-optional",children:"\ud83e\udde9 Adding User Interface (optional)"}),"\n",(0,i.jsxs)(n.p,{children:["We will use the ",(0,i.jsx)(n.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,i.jsx)(n.code,{children:"init"})," method of the ",(0,i.jsx)(n.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,i.jsx)(n.p,{children:"Now we will add some UI to handle the logic of this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const panel = BUI.Component.create<BUI.PanelSection>(() => {\r\n  const onDisplayCountClick = async () => {\r\n    const { visible, hidden } = await getVisibilityByCategory("IFCSLAB");\r\n    window.alert(\r\n      `Visible Slabs: ${visible}.\r\nHidden Slabs: ${hidden}.`,\r\n    );\r\n  };\r\n\r\n  const onDisplayVisibilityCount = async () => {\r\n    const { visible, hidden } = await getVisibilityCount();\r\n    window.alert(\r\n      `Visible: ${visible} items.\r\nHidden: ${hidden} items.`,\r\n    );\r\n  };\r\n\r\n  return BUI.html`\r\n    <bim-panel active label="Fragments Visibility" class="options-menu">\r\n      <bim-panel-section fixed label="Controls">\r\n        <bim-button label="Toggle Roofs" @click=${() => toggleVisibilityByCategory("IFCROOF")}></bim-button>  \r\n        <bim-button label="Toggle Walls" @click=${() => toggleVisibilityByCategory("IFCWALL")}></bim-button>  \r\n        <bim-button label="Toggle Slabs" @click=${() => toggleVisibilityByCategory("IFCSLAB")}></bim-button>  \r\n        <bim-button label="Display Slab Visibility" @click=${onDisplayCountClick}></bim-button>  \r\n        <bim-button label="Display Visibility State" @click=${onDisplayVisibilityCount}></bim-button>  \r\n      </bim-panel-section>\r\n    </bim-panel>\r\n  `;\r\n});\r\n\r\ndocument.body.append(panel);\n'})}),"\n",(0,i.jsx)(n.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\r\n  const onClick = () => {\r\n    if (panel.classList.contains("options-menu-visible")) {\r\n      panel.classList.remove("options-menu-visible");\r\n    } else {\r\n      panel.classList.add("options-menu-visible");\r\n    }\r\n  };\r\n\r\n  return BUI.html`\r\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\r\n      @click=${onClick}>\r\n    </bim-button>\r\n  `;\r\n});\r\n\r\ndocument.body.append(button);\n'})}),"\n",(0,i.jsx)(n.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,i.jsxs)(n.p,{children:["We'll use the ",(0,i.jsx)(n.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const stats = new Stats();\r\nstats.showPanel(2);\r\ndocument.body.append(stats.dom);\r\nstats.dom.style.left = "0px";\r\nstats.dom.style.zIndex = "unset";\r\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\r\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,i.jsx)(n.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,i.jsx)(n.p,{children:"You've successfully mastered visibility management in Fragments!\r\nBy following this tutorial, you've learned how to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Hide specific elements in your 3D models."}),"\n",(0,i.jsx)(n.li,{children:"Toggle visibility dynamically based on categories."}),"\n",(0,i.jsx)(n.li,{children:"Retrieve visibility states for better control and insights."}),"\n",(0,i.jsx)(n.li,{children:"Add a user-friendly interface to manage visibility operations."}),"\n",(0,i.jsx)(n.li,{children:"Measure performance to ensure a smooth user experience.\r\nKeep experimenting and building amazing 3D applications with Fragments. \ud83d\ude80"}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);