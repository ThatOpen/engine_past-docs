"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[6170],{8324:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(4848),a=n(8453);const o={},s=void 0,i={id:"Tutorials/Fragments/Fragments/ModelInformation",title:"ModelInformation",description:'window.open("https://thatopen.github.io/engine_fragment/examples/ModelInformation")} >Go Full Screen',source:"@site/docs/Tutorials/Fragments/Fragments/ModelInformation.mdx",sourceDirName:"Tutorials/Fragments/Fragments",slug:"/Tutorials/Fragments/Fragments/ModelInformation",permalink:"/engine_past-docs/3.0.x/Tutorials/Fragments/Fragments/ModelInformation",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"IfcImporter",permalink:"/engine_past-docs/3.0.x/Tutorials/Fragments/Fragments/IfcImporter"},next:{title:"Raycasting",permalink:"/engine_past-docs/3.0.x/Tutorials/Fragments/Fragments/Raycasting"}},l={},c=[{value:"Getting Your Fragments Model Information \ud83d\uddd2\ufe0f",id:"getting-your-fragments-model-information-\ufe0f",level:2},{value:"\ud83d\udd96 Importing our Libraries",id:"-importing-our-libraries",level:3},{value:"\ud83c\udf0e Setting up a Simple Scene",id:"-setting-up-a-simple-scene",level:3},{value:"\ud83d\udee0\ufe0f Setting Up Fragments",id:"\ufe0f-setting-up-fragments",level:3},{value:"\ud83d\udcc2 Loading a Fragments Model",id:"-loading-a-fragments-model",level:3},{value:"\ud83e\udd0f Setting Up Raycaster",id:"-setting-up-raycaster",level:3},{value:"\ud83d\uddd2\ufe0f Getting Item Attributes",id:"\ufe0f-getting-item-attributes",level:3},{value:"\ud83d\udd17 Retrieving Item Relations",id:"-retrieving-item-relations",level:3},{value:"\ud83d\udcca More Data Operations",id:"-more-data-operations",level:3},{value:"\ud83c\udf10 Exploring the Spatial Structure",id:"-exploring-the-spatial-structure",level:3},{value:"\ud83e\uddf1 Accessing Geometry Data",id:"-accessing-geometry-data",level:3},{value:"\ud83e\udde9 Adding User Interface (optional)",id:"-adding-user-interface-optional",level:3},{value:"\u23f1\ufe0f Measuring the performance (optional)",id:"\ufe0f-measuring-the-performance-optional",level:3},{value:"\ud83c\udf89 Congratulations!",id:"-congratulations",level:3}];function m(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",hr:"hr",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)("div",{style:{position:"relative"},children:[(0,r.jsx)("iframe",{src:"https://thatopen.github.io/engine_fragment/examples/ModelInformation"}),(0,r.jsx)("button",{class:"full-screen-btn",onClick:()=>window.open("https://thatopen.github.io/engine_fragment/examples/ModelInformation"),children:"Go Full Screen"})]}),"\n",(0,r.jsx)(t.admonition,{title:"Source",type:"info",children:(0,r.jsxs)(t.p,{children:["Copying and pasting? We've got you covered! You can find the full source code of this tutorial ",(0,r.jsx)(t.a,{href:"https://github.com/ThatOpen/engine_fragment/blob/a3f91db6422f752fd5dc26532d6cf29eb989b677/packages/fragments/src/FragmentsModels/samples/ModelInformation/example.ts",children:"here"}),"."]})}),"\n",(0,r.jsx)(t.h2,{id:"getting-your-fragments-model-information-\ufe0f",children:"Getting Your Fragments Model Information \ud83d\uddd2\ufe0f"}),"\n",(0,r.jsx)(t.hr,{}),"\n",(0,r.jsx)(t.p,{children:"A BIM model is only as valuable as the information it provides. Retrieving specific data efficiently is crucial for any workflow. In this tutorial, you'll learn how to extract and utilize data from Fragments with ease!"}),"\n",(0,r.jsx)(t.h3,{id:"-importing-our-libraries",children:"\ud83d\udd96 Importing our Libraries"}),"\n",(0,r.jsx)(t.p,{children:"First things first, let's install all necessary dependencies to make this example work:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'import * as THREE from "three";\r\nimport * as OBC from "@thatopen/components";\r\nimport * as BUI from "@thatopen/ui";\r\nimport Stats from "stats.js";\r\n// You have to import * as FRAGS from "@thatopen/fragments"\r\nimport * as FRAGS from "../../..";\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-setting-up-a-simple-scene",children:"\ud83c\udf0e Setting up a Simple Scene"}),"\n",(0,r.jsx)(t.p,{children:"To get started, let's set up a basic ThreeJS scene. This will serve as the foundation for our application and allow us to visualize the 3D models effectively:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const components = new OBC.Components();\r\n\r\nconst worlds = components.get(OBC.Worlds);\r\nconst world = worlds.create<\r\n  OBC.SimpleScene,\r\n  OBC.SimpleCamera,\r\n  OBC.SimpleRenderer\r\n>();\r\n\r\nworld.scene = new OBC.SimpleScene(components);\r\nworld.scene.setup();\r\nworld.scene.three.background = null;\r\n\r\nconst container = document.getElementById("container")!;\r\nworld.renderer = new OBC.SimpleRenderer(components, container);\r\n\r\nworld.camera = new OBC.SimpleCamera(components);\r\nworld.camera.controls.setLookAt(183, 11, -102, 27, -52, -11); // convenient position for the model we will load\r\n\r\ncomponents.init();\r\n\r\nconst grids = components.get(OBC.Grids);\r\ngrids.create(world);\n'})}),"\n",(0,r.jsx)(t.admonition,{title:"Do I need @thatopen/components?",type:"info",children:(0,r.jsx)(t.p,{children:"Not necessarily! While @thatopen/components simplifies the process of setting up a scene, you can always use plain ThreeJS to create your own custom scene setup. It's entirely up to your preference and project requirements! \ud83d\ude09"})}),"\n",(0,r.jsx)(t.h3,{id:"\ufe0f-setting-up-fragments",children:"\ud83d\udee0\ufe0f Setting Up Fragments"}),"\n",(0,r.jsx)(t.p,{children:"Now, let's configure the Fragments library core. This will allow us to load models effortlessly and start manipulating them with ease:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// You can copy `/node_modules/@thatopen/fragments/dist/Worker/worker.mjs` to your project directory\r\n// and provide the relative path of the worker, or fetch it from github, unpkg, etc.\r\nconst workerUrl =\r\n  "https://thatopen.github.io/engine_fragment/resources/worker.mjs";\r\nconst fetchedWorker = await fetch(workerUrl);\r\nconst workerText = await fetchedWorker.text();\r\nconst workerFile = new File([new Blob([workerText])], "worker.mjs", {\r\n  type: "text/javascript",\r\n});\r\nconst url = URL.createObjectURL(workerFile);\r\nconst fragments = new FRAGS.FragmentsModels(url);\r\nworld.camera.controls.addEventListener("rest", () => fragments.update(true));\r\nworld.camera.controls.addEventListener("update", () => fragments.update());\r\n\r\n// Once a model is available in the list, we can tell what camera to use\r\n// in order to perform the culling and LOD operations.\r\n// Also, we add the model to the 3D scene.\r\nfragments.models.list.onItemSet.add(({ value: model }) => {\r\n  model.useCamera(world.camera.three);\r\n  world.scene.three.add(model.object);\r\n  // At the end, you tell fragments to update so the model can be seen given\r\n  // the initial camera position\r\n  fragments.update(true);\r\n});\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-loading-a-fragments-model",children:"\ud83d\udcc2 Loading a Fragments Model"}),"\n",(0,r.jsx)(t.p,{children:"With the core setup complete, it's time to load a Fragments model into our scene. Fragments are optimized for fast loading and rendering, making them ideal for large-scale 3D models."}),"\n",(0,r.jsx)(t.admonition,{title:"Where can I find Fragment files?",type:"info",children:(0,r.jsx)(t.p,{children:"You can use the sample Fragment files available in our repository for testing. If you have an IFC model you'd like to convert to Fragments, check out the IfcImporter tutorial for detailed instructions."})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const file = await fetch(\r\n  "https://thatopen.github.io/engine_fragment/resources/frags/school_arq.frag",\r\n);\r\nconst buffer = await file.arrayBuffer();\r\nconst model = await fragments.load(buffer, { modelId: "example" });\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-setting-up-raycaster",children:"\ud83e\udd0f Setting Up Raycaster"}),"\n",(0,r.jsx)(t.p,{children:"To enable element selection and information querying in this example, let's configure a straightforward raycasting operation for the model:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const highlightMaterial: FRAGS.MaterialDefinition = {\r\n  color: new THREE.Color("gold"),\r\n  renderedFaces: FRAGS.RenderedFaces.TWO,\r\n  opacity: 1,\r\n  transparent: false,\r\n};\r\n\r\nlet localId: number | null = null;\r\n\r\nconst highlight = async () => {\r\n  if (!localId) return;\r\n  await model.highlight([localId], highlightMaterial);\r\n};\r\n\r\nconst resetHighlight = async () => {\r\n  if (!localId) return;\r\n  await model.resetHighlight([localId]);\r\n};\r\n\r\nlet onItemSelected = () => {};\r\nlet onItemDeselected = () => {};\r\n\r\nconst mouse = new THREE.Vector2();\r\ncontainer.addEventListener("click", async (event) => {\r\n  mouse.x = event.clientX;\r\n  mouse.y = event.clientY;\r\n  const result = await model.raycast({\r\n    camera: world.camera.three,\r\n    mouse,\r\n    dom: world.renderer!.three.domElement!,\r\n  });\r\n  const promises = [];\r\n  if (result) {\r\n    promises.push(resetHighlight());\r\n    localId = result.localId;\r\n    onItemSelected();\r\n    promises.push(highlight());\r\n  } else {\r\n    promises.push(resetHighlight());\r\n    localId = null;\r\n    onItemDeselected();\r\n  }\r\n  promises.push(fragments.update(true));\r\n  Promise.all(promises);\r\n});\n'})}),"\n",(0,r.jsx)(t.admonition,{title:"Raycasting",type:"info",children:(0,r.jsx)(t.p,{children:"If you're unfamiliar with the raycasting logic above, we recommend checking out the dedicated raycasting tutorial. It provides a detailed explanation and step-by-step guidance to help you understand how raycasting works in this context."})}),"\n",(0,r.jsx)(t.h3,{id:"\ufe0f-getting-item-attributes",children:"\ud83d\uddd2\ufe0f Getting Item Attributes"}),"\n",(0,r.jsx)(t.p,{children:"Great! With the raycasting setup complete, let's move on to the exciting part: extracting information. To begin, we'll create a handy function to retrieve the direct attributes of the selected item in the scene:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const getAttributes = async (attributes?: string[]) => {\r\n  if (!localId) return null;\r\n  // This model method is the most straightforward way to get information\r\n  // about one or multiple elements.\r\n  // You can see the options in the API reference.\r\n  const [data] = await model.getItemsData([localId], {\r\n    attributesDefault: !attributes,\r\n    attributes,\r\n  });\r\n  return data;\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:"The function above is designed to retrieve all attributes if none are specified. However, if you're only interested in a specific set of attributes, you can easily pass them as parameters. Let's create a function that retrieves just the name of the selected item:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const getName = async () => {\r\n  const attributes = await getAttributes(["Name"]);\r\n  const Name = attributes?.Name;\r\n  if (!(Name && "value" in Name)) return null;\r\n  return Name.value as "string";\r\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-retrieving-item-relations",children:"\ud83d\udd17 Retrieving Item Relations"}),"\n",(0,r.jsx)(t.p,{children:"Accessing the direct attributes of an item is useful, but the true power lies in exploring its relationships. Items can be interconnected through relations, enabling you to understand their context and associations. For instance, a level can contain walls, and walls can reference the level they belong to. These relationships are often defined in the source file from which the Fragments were converted.\r\nFor Fragments derived from IFC files, the possible relations and their names are determined by the IFC schema. Let's create a helper function to retrieve all Property Sets (Psets) associated with the selected item, leveraging these relationships."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'// `IsDefinedBy` is the relationship that links property sets (psets) to the element they define.\r\n// `DefinesOccurrence` is the relationship that links a property set to the elements that use it.\r\n// In this case, we don\'t need to know the elements that have the psets (just the psets of the selected element)\r\n// Then we don\'t want to get DefinesOcurrences items and that\'s by attributes and relations are set to false.\r\n// For more information, please refer to the IFC schema documentation\r\nconst getItemPropertySets = async () => {\r\n  if (!localId) return null;\r\n  const [data] = await model.getItemsData([localId], {\r\n    attributesDefault: false,\r\n    attributes: ["Name", "NominalValue"],\r\n    relations: {\r\n      IsDefinedBy: { attributes: true, relations: true },\r\n      DefinesOcurrence: { attributes: false, relations: false },\r\n    },\r\n  });\r\n  return (data.IsDefinedBy as FRAGS.ItemData[]) ?? [];\r\n};\n'})}),"\n",(0,r.jsx)(t.p,{children:"The data returned from the function above is structured similarly to how it's stored internally in the Fragments file. However, this format might not always be regular-developer-friendly. To make it more convenient, let's create a function that formats the result into a regular object for easier consumption:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const formatItemPsets = (rawPsets: FRAGS.ItemData[]) => {\r\n  const result: Record<string, Record<string, any>> = {};\r\n  for (const [_, pset] of rawPsets.entries()) {\r\n    const { Name: psetName, HasProperties } = pset;\r\n    if (!("value" in psetName && Array.isArray(HasProperties))) continue;\r\n    const props: Record<string, any> = {};\r\n    for (const [_, prop] of HasProperties.entries()) {\r\n      const { Name, NominalValue } = prop;\r\n      if (!("value" in Name && "value" in NominalValue)) continue;\r\n      const name = Name.value;\r\n      const nominalValue = NominalValue.value;\r\n      if (!(name && nominalValue !== undefined)) continue;\r\n      props[name] = nominalValue;\r\n    }\r\n    result[psetName.value] = props;\r\n  }\r\n  return result;\r\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-more-data-operations",children:"\ud83d\udcca More Data Operations"}),"\n",(0,r.jsx)(t.p,{children:"Beyond accessing attributes and relationships, you can also retrieve the full list of categories in the model. This enables convenient operations like fetching all elements from a specific category, which is a common use case. Let's create a function to retrieve all item names from a given category:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const getNamesFromCategory = async (category: string, unique = false) => {\r\n  const items = await model.getItemsOfCategory(category);\r\n  const localIds = (\r\n    await Promise.all(items.map((item) => item.getLocalId()))\r\n  ).filter((localId) => localId !== null) as number[];\r\n\r\n  const data = await model.getItemsData(localIds, {\r\n    attributesDefault: false,\r\n    attributes: ["Name"],\r\n  });\r\n\r\n  const names = data\r\n    .map((d) => {\r\n      const { Name } = d;\r\n      if (!(Name && !Array.isArray(Name))) return null;\r\n      return Name.value;\r\n    })\r\n    .filter((name) => name) as string[];\r\n\r\n  return unique ? [...new Set(names)] : names;\r\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-exploring-the-spatial-structure",children:"\ud83c\udf10 Exploring the Spatial Structure"}),"\n",(0,r.jsx)(t.p,{children:"The spatial structure is a fundamental aspect of any BIM model, as it defines the hierarchical relationships between elements. With Fragments, retrieving this structure is straightforward. Here's how you can do it:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const getSpatialStructure = async () => {\r\n  const result = await model.getSpatialStructure();\r\n  return result;\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now, thanks to the spatial structure present in the model, you can perform useful operations, such as retrieving all children of a specific item. This parent/child relationship is derived from the spatial structure, so ensure the structure accurately reflects these relationships to make the following function effective:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const getFirstLevelChildren = async () => {\r\n  const items = await model.getItemsOfCategory("IFCBUILDINGSTOREY");\r\n  const localIds = (\r\n    await Promise.all(items.map((item) => item.getLocalId()))\r\n  ).filter((localId) => localId !== null) as number[];\r\n\r\n  const attributes = await model.getItemsData(localIds, {\r\n    attributesDefault: false,\r\n    attributes: ["Name"],\r\n  });\r\n\r\n  let firstLevelLocalId = null;\r\n\r\n  for (const [index, data] of attributes.entries()) {\r\n    if (!("Name" in data && "value" in data.Name)) continue;\r\n    if (data.Name.value === "01 - Entry Level") {\r\n      firstLevelLocalId = localIds[index];\r\n    }\r\n  }\r\n\r\n  if (firstLevelLocalId === null) return null;\r\n\r\n  const children = await model.getItemsChildren([firstLevelLocalId]);\r\n  return children;\r\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-accessing-geometry-data",children:"\ud83e\uddf1 Accessing Geometry Data"}),"\n",(0,r.jsx)(t.p,{children:"A key reason why a FragmentsModel is highly memory-efficient is that all BufferAttributes from the geometry in ThreeJS are removed after being used to render the model in the scene. However, all the data you see in the model, including the explicit geometry used to create the meshes in the first place, is stored within the Fragments file. Fortunately, retrieving this information is straightforward in case you need it. Here's how you can do it:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const getItemGeometry = async () => {\r\n  if (!localId) return null;\r\n  const [geometryCollection] = await model.getItemsGeometry([localId]);\r\n  return geometryCollection;\r\n};\n"})}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsx)(t.p,{children:"Keep in mind that a single item may consist of multiple geometries. This is why the model method used above returns a nested array structure: the outer array represents the collection of items, while the inner arrays contain the geometries associated with each item."})}),"\n",(0,r.jsx)(t.p,{children:"You can combine this with retrieving items from a category to obtain the complete explicit geometry of a specific group of elements."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const getGeometriesFromCategory = async (category: string) => {\r\n  const items = await model.getItemsOfCategory(category);\r\n  const localIds = (\r\n    await Promise.all(items.map((item) => item.getLocalId()))\r\n  ).filter((localId) => localId !== null) as number[];\r\n\r\n  const geometries = await model.getItemsGeometry(localIds);\r\n  return { localIds, geometries };\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:"Finally, you can easily create a new ThreeJS mesh using any geometry data retrieved from the FragmentsModel. Here's how:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'let meshes: THREE.Mesh[] = [];\r\n\r\nconst meshMaterial = new THREE.MeshLambertMaterial({ color: "purple" });\r\n\r\nconst createMesh = (data: FRAGS.MeshData) => {\r\n  const { positions, indices, normals, transform } = data;\r\n  if (!(positions && indices && normals)) return null;\r\n  const geometry = new THREE.BufferGeometry();\r\n  geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));\r\n  geometry.setAttribute("normal", new THREE.BufferAttribute(normals, 3));\r\n  geometry.setIndex(Array.from(indices));\r\n\r\n  const mesh = new THREE.Mesh(geometry, meshMaterial);\r\n  mesh.applyMatrix4(transform);\r\n  meshes.push(mesh);\r\n  return mesh;\r\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-adding-user-interface-optional",children:"\ud83e\udde9 Adding User Interface (optional)"}),"\n",(0,r.jsxs)(t.p,{children:["We will use the ",(0,r.jsx)(t.code,{children:"@thatopen/ui"})," library to add some simple and cool UI elements to our app. First, we need to call the ",(0,r.jsx)(t.code,{children:"init"})," method of the ",(0,r.jsx)(t.code,{children:"BUI.Manager"})," class to initialize the library:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"BUI.Manager.init();\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now we will add some UI to handle the logic of this tutorial. For more information about the UI library, you can check the specific documentation for it!"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const categories = await model.getCategories();\r\nconst categoriesDropdown = BUI.Component.create<BUI.Dropdown>(\r\n  () => BUI.html`<bim-dropdown name="categories">\r\n    ${categories.map(\r\n      (category) => BUI.html`<bim-option label=${category}></bim-option>`,\r\n    )}\r\n  </bim-dropdown>`,\r\n);\r\n\r\nconst [panel, updatePanel] = BUI.Component.create<BUI.PanelSection, any>(\r\n  (_) => {\r\n    const onLogAttributes = async () => {\r\n      const data = await getAttributes();\r\n      if (!data) return;\r\n      console.log(data);\r\n    };\r\n\r\n    const onLogPsets = async () => {\r\n      const data = await getItemPropertySets();\r\n      if (!data) return;\r\n      const panel = document.getElementById("controls-panel");\r\n      const checkbox = panel?.querySelector<BUI.Checkbox>(\'[name="format"]\');\r\n      const result = checkbox?.value ? formatItemPsets(data) : data;\r\n      console.log(result);\r\n    };\r\n\r\n    const onNamesFromCategory = async ({ target }: { target: BUI.Button }) => {\r\n      const panel = document.getElementById("controls-panel");\r\n      const [category] = categoriesDropdown.value;\r\n      if (!category) return;\r\n      target.loading = true;\r\n      const checkbox = panel?.querySelector<BUI.Checkbox>(\'[name="unique"]\');\r\n      const data = await getNamesFromCategory(category, checkbox?.value);\r\n      target.loading = false;\r\n      console.log(data);\r\n    };\r\n\r\n    const onGeometriesFromCategory = async ({\r\n      target,\r\n    }: {\r\n      target: BUI.Button;\r\n    }) => {\r\n      const [category] = categoriesDropdown.value;\r\n      if (!category) return;\r\n      target.loading = true;\r\n      const { localIds, geometries: data } =\r\n        await getGeometriesFromCategory(category);\r\n      for (const value of data) {\r\n        for (const meshData of value) {\r\n          const mesh = createMesh(meshData);\r\n          if (!mesh) continue;\r\n          world.scene.three.add(mesh);\r\n        }\r\n      }\r\n      await model.setVisible(localIds, false);\r\n      await fragments.update(true);\r\n      target.loading = false;\r\n      console.log(data);\r\n    };\r\n\r\n    const onDisposeMeshes = async () => {\r\n      for (const mesh of meshes) {\r\n        mesh.removeFromParent();\r\n        mesh.geometry.dispose();\r\n        const materials = Array.isArray(mesh.material)\r\n          ? mesh.material\r\n          : [mesh.material];\r\n        for (const material of materials) {\r\n          material.dispose();\r\n        }\r\n      }\r\n      meshes = [];\r\n      await model.setVisible(undefined, true);\r\n      await fragments.update(true);\r\n    };\r\n\r\n    const onNameLabelCreated = async (e?: Element) => {\r\n      if (!e) return;\r\n      const label = e as BUI.Label;\r\n      label.textContent = await getName();\r\n    };\r\n\r\n    const onLogStructure = async ({ target }: { target: BUI.Button }) => {\r\n      target.loading = true;\r\n      const result = await getSpatialStructure();\r\n      console.log(result);\r\n      target.loading = false;\r\n    };\r\n\r\n    const onLogGeometry = async ({ target }: { target: BUI.Button }) => {\r\n      target.loading = true;\r\n      const result = await getItemGeometry();\r\n      console.log(result);\r\n      target.loading = false;\r\n    };\r\n\r\n    const onLogLevelItems = async ({ target }: { target: BUI.Button }) => {\r\n      target.loading = true;\r\n      const result = await getFirstLevelChildren();\r\n      if (!result) {\r\n        target.loading = false;\r\n        return;\r\n      }\r\n      const panel = document.getElementById("controls-panel");\r\n      const checkbox = panel?.querySelector<BUI.Checkbox>(\r\n        \'[name="displayNames"]\',\r\n      );\r\n      if (checkbox) {\r\n        const attrs = await model.getItemsData(result, {\r\n          attributesDefault: false,\r\n          attributes: ["Name"],\r\n        });\r\n        const names = attrs.map((data) => {\r\n          if (!("Name" in data && "value" in data.Name)) return null;\r\n          return data.Name.value;\r\n        });\r\n        console.log(names);\r\n      } else {\r\n        console.log(result);\r\n      }\r\n      target.loading = false;\r\n    };\r\n\r\n    return BUI.html`\r\n    <bim-panel id="controls-panel" active label="Model Information" class="options-menu">\r\n      <bim-panel-section fixed label="Info">\r\n        <bim-label style="white-space: normal;">\ud83d\udca1 To better experience this tutorial, open your browser console to see the data logs.</bim-label>\r\n      </bim-panel-section>\r\n      <bim-panel-section label="Selected Item">\r\n        <bim-label style=${BUI.styleMap({ whiteSpace: "normal", display: localId ? "none" : "unset" })}>\ud83d\udca1 Click any element in the viewer to activate the data log options.</bim-label>\r\n        <bim-label ${BUI.ref(onNameLabelCreated)} style=${BUI.styleMap({ whiteSpace: "normal", display: !localId ? "none" : "unset" })}></bim-label>\r\n        <bim-button ?disabled=${!localId} label="Log Attributes" @click=${onLogAttributes}></bim-button>\r\n        <div style="display: flex; gap: 0.5rem">\r\n          <bim-button ?disabled=${!localId} label="Log Psets" @click=${onLogPsets}></bim-button>\r\n          <bim-checkbox name="format" label="Format" inverted checked></bim-checkbox>\r\n        </div>\r\n        <bim-button ?disabled=${!localId} label="Log Geometry" @click=${onLogGeometry}></bim-button>\r\n      </bim-panel-section>\r\n      <bim-panel-section label="Categories">\r\n        ${categoriesDropdown}\r\n        <div style="display: flex; gap: 0.5rem">\r\n          <bim-button label="Log Names" @click=${onNamesFromCategory}></bim-button>\r\n          <bim-checkbox name="unique" label="Unique" inverted></bim-checkbox>\r\n        </div>\r\n        <bim-button label="Log Geometries" @click=${onGeometriesFromCategory}></bim-button>\r\n        <bim-button label="Dispose Meshes" @click=${onDisposeMeshes}></bim-button>\r\n      </bim-panel-section>\r\n      <bim-panel-section label="Spatial Structure">\r\n        <bim-button label="Log Spatial Structure" @click=${onLogStructure}></bim-button>\r\n        <div style="display: flex; gap: 0.5rem">\r\n          <bim-button label="Log First Level Items" @click=${onLogLevelItems}></bim-button>\r\n          <bim-checkbox name="displayNames" label="Names" inverted></bim-checkbox>\r\n        </div>\r\n      </bim-panel-section>\r\n    </bim-panel>\r\n  `;\r\n  },\r\n  {},\r\n);\r\n\r\nonItemSelected = () => updatePanel();\r\nonItemDeselected = () => updatePanel();\r\ndocument.body.append(panel);\n'})}),"\n",(0,r.jsx)(t.p,{children:"And we will make some logic that adds a button to the screen when the user is visiting our app from their phone, allowing to show or hide the menu. Otherwise, the menu would make the app unusable."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const button = BUI.Component.create<BUI.PanelSection>(() => {\r\n  const onClick = () => {\r\n    if (panel.classList.contains("options-menu-visible")) {\r\n      panel.classList.remove("options-menu-visible");\r\n    } else {\r\n      panel.classList.add("options-menu-visible");\r\n    }\r\n  };\r\n\r\n  return BUI.html`\r\n    <bim-button class="phone-menu-toggler" icon="solar:settings-bold"\r\n      @click=${onClick}>\r\n    </bim-button>\r\n  `;\r\n});\r\n\r\ndocument.body.append(button);\n'})}),"\n",(0,r.jsx)(t.h3,{id:"\ufe0f-measuring-the-performance-optional",children:"\u23f1\ufe0f Measuring the performance (optional)"}),"\n",(0,r.jsxs)(t.p,{children:["We'll use the ",(0,r.jsx)(t.a,{href:"https://github.com/mrdoob/stats.js",children:"Stats.js"})," to measure the performance of our app. We will add it to the top left corner of the viewport. This way, we'll make sure that the memory consumption and the FPS of our app are under control."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const stats = new Stats();\r\nstats.showPanel(2);\r\ndocument.body.append(stats.dom);\r\nstats.dom.style.left = "0px";\r\nstats.dom.style.zIndex = "unset";\r\nworld.renderer.onBeforeUpdate.add(() => stats.begin());\r\nworld.renderer.onAfterUpdate.add(() => stats.end());\n'})}),"\n",(0,r.jsx)(t.h3,{id:"-congratulations",children:"\ud83c\udf89 Congratulations!"}),"\n",(0,r.jsx)(t.p,{children:"You've successfully mastered the art of retrieving information from your FragmentsModel! \ud83d\ude80\r\nWith this knowledge, you're now equipped to explore, manipulate, and extract valuable insights from your BIM models. Keep experimenting and building amazing applications! \ud83d\udca1"})]})}function d(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(m,{...e})}):m(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var r=n(6540);const a={},o=r.createContext(a);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);