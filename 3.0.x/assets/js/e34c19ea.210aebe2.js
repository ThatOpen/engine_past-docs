"use strict";(self.webpackChunkengine_docs=self.webpackChunkengine_docs||[]).push([[4927],{2016:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>a,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var i=s(4848),r=s(8453);const t={},d="BoundingBoxer",l={id:"api/@thatopen/components/classes/BoundingBoxer",title:"BoundingBoxer",description:"A simple implementation of bounding box that works for fragments. The resulting bbox is not 100% precise, but it's fast, and should suffice for general use cases such as camera zooming or general boundary determination. \ud83d\udcd5 Tutorial. \ud83d\udcd8 API.",source:"@site/docs/api/@thatopen/components/classes/BoundingBoxer.md",sourceDirName:"api/@thatopen/components/classes",slug:"/api/@thatopen/components/classes/BoundingBoxer",permalink:"/3.0.x/api/@thatopen/components/classes/BoundingBoxer",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"abstract BaseWorldItem",permalink:"/3.0.x/api/@thatopen/components/classes/BaseWorldItem"},next:{title:"Classifier",permalink:"/3.0.x/api/@thatopen/components/classes/Classifier"}},o={},c=[{value:"Extends",id:"extends",level:2},{value:"Implements",id:"implements",level:2},{value:"Properties",id:"properties",level:2},{value:"enabled",id:"enabled",level:3},{value:"Overrides",id:"overrides",level:4},{value:"onDisposed",id:"ondisposed",level:3},{value:"Implementation of",id:"implementation-of",level:4},{value:"Methods",id:"methods",level:2},{value:"add()",id:"add",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns",level:4},{value:"Remarks",id:"remarks",level:4},{value:"Example",id:"example",level:4},{value:"addFragmentIdMap()",id:"addfragmentidmap",level:3},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Remarks",id:"remarks-1",level:4},{value:"Example",id:"example-1",level:4},{value:"addMesh()",id:"addmesh",level:3},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-2",level:4},{value:"Remarks",id:"remarks-2",level:4},{value:"Example",id:"example-2",level:4},{value:"dispose()",id:"dispose",level:3},{value:"Returns",id:"returns-3",level:4},{value:"Implementation of",id:"implementation-of-1",level:4},{value:"get()",id:"get",level:3},{value:"Returns",id:"returns-4",level:4},{value:"Remarks",id:"remarks-3",level:4},{value:"Example",id:"example-3",level:4},{value:"getMesh()",id:"getmesh",level:3},{value:"Returns",id:"returns-5",level:4},{value:"Remarks",id:"remarks-4",level:4},{value:"Example",id:"example-4",level:4},{value:"getSphere()",id:"getsphere",level:3},{value:"Returns",id:"returns-6",level:4},{value:"Remarks",id:"remarks-5",level:4},{value:"Example",id:"example-5",level:4},{value:"isConfigurable()",id:"isconfigurable",level:3},{value:"Returns",id:"returns-7",level:4},{value:"Inherited from",id:"inherited-from",level:4},{value:"isDisposeable()",id:"isdisposeable",level:3},{value:"Returns",id:"returns-8",level:4},{value:"Inherited from",id:"inherited-from-1",level:4},{value:"isHideable()",id:"ishideable",level:3},{value:"Returns",id:"returns-9",level:4},{value:"Inherited from",id:"inherited-from-2",level:4},{value:"isResizeable()",id:"isresizeable",level:3},{value:"Returns",id:"returns-10",level:4},{value:"Inherited from",id:"inherited-from-3",level:4},{value:"isUpdateable()",id:"isupdateable",level:3},{value:"Returns",id:"returns-11",level:4},{value:"Inherited from",id:"inherited-from-4",level:4},{value:"reset()",id:"reset",level:3},{value:"Returns",id:"returns-12",level:4},{value:"Remarks",id:"remarks-6",level:4},{value:"Example",id:"example-6",level:4},{value:"getBounds()",id:"getbounds",level:3},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-13",level:4},{value:"Remarks",id:"remarks-7",level:4},{value:"Example",id:"example-7",level:4},{value:"getDimensions()",id:"getdimensions",level:3},{value:"Parameters",id:"parameters-4",level:4},{value:"Returns",id:"returns-14",level:4},{value:"center",id:"center",level:5},{value:"depth",id:"depth",level:5},{value:"height",id:"height",level:5},{value:"width",id:"width",level:5},{value:"newBound()",id:"newbound",level:3},{value:"Parameters",id:"parameters-5",level:4},{value:"Returns",id:"returns-15",level:4},{value:"Remarks",id:"remarks-8",level:4},{value:"Example",id:"example-8",level:4}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"boundingboxer",children:"BoundingBoxer"}),"\n",(0,i.jsxs)(n.p,{children:["A simple implementation of bounding box that works for fragments. The resulting bbox is not 100% precise, but it's fast, and should suffice for general use cases such as camera zooming or general boundary determination. \ud83d\udcd5 ",(0,i.jsx)(n.a,{href:"https://docs.thatopen.com/Tutorials/Components/Core/BoundingBoxer",children:"Tutorial"}),". \ud83d\udcd8 ",(0,i.jsx)(n.a,{href:"https://docs.thatopen.com/api/@thatopen/components/classes/BoundingBoxer",children:"API"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"extends",children:"Extends"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implements",children:"Implements"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable",children:(0,i.jsx)(n.code,{children:"Disposable"})})}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,i.jsx)(n.h3,{id:"enabled",children:"enabled"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"enabled"}),": ",(0,i.jsx)(n.code,{children:"boolean"})," = ",(0,i.jsx)(n.code,{children:"true"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#enabled",children:"Component.enabled"})}),"\n",(0,i.jsx)(n.h4,{id:"overrides",children:"Overrides"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#enabled",children:(0,i.jsx)(n.code,{children:"enabled"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"ondisposed",children:"onDisposed"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"readonly"})," ",(0,i.jsx)(n.strong,{children:"onDisposed"}),": ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Event",children:(0,i.jsx)(n.code,{children:"Event"})}),"<",(0,i.jsx)(n.code,{children:"unknown"}),">"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable#ondisposed",children:"Disposable.onDisposed"})}),"\n",(0,i.jsx)(n.h4,{id:"implementation-of",children:"Implementation of"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable",children:(0,i.jsx)(n.code,{children:"Disposable"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable#ondisposed",children:(0,i.jsx)(n.code,{children:"onDisposed"})})]}),"\n",(0,i.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,i.jsx)(n.h3,{id:"add",children:"add()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"add"}),"(",(0,i.jsx)(n.code,{children:"group"}),"): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Adds a FragmentsGroup to the BoundingBoxer."}),"\n",(0,i.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"group"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"FragmentsGroup"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"The FragmentsGroup to add."})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"void"})}),"\n",(0,i.jsx)(n.h4,{id:"remarks",children:"Remarks"}),"\n",(0,i.jsxs)(n.p,{children:["This method iterates through each fragment in the provided FragmentsGroup,\r\nand calls the ",(0,i.jsx)(n.code,{children:"addMesh"})," method for each fragment's mesh."]}),"\n",(0,i.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBoxer = components.get(BoundingBoxer);\r\nboundingBoxer.add(fragmentsGroup);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"addfragmentidmap",children:"addFragmentIdMap()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"addFragmentIdMap"}),"(",(0,i.jsx)(n.code,{children:"fragmentIdMap"}),"): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Uses a FragmentIdMap to add its meshes to the bb calculation."}),"\n",(0,i.jsxs)(n.p,{children:["This method iterates through the provided ",(0,i.jsx)(n.code,{children:"fragmentIdMap"}),", retrieves the corresponding fragment from the ",(0,i.jsx)(n.code,{children:"FragmentsManager"}),",\r\nand then calls the ",(0,i.jsx)(n.code,{children:"addMesh"})," method for each fragment's mesh, passing the expression IDs as the second parameter."]}),"\n",(0,i.jsx)(n.h4,{id:"parameters-1",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"fragmentIdMap"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"FragmentIdMap"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"A mapping of fragment IDs to their corresponding expression IDs."})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"void"})}),"\n",(0,i.jsx)(n.h4,{id:"remarks-1",children:"Remarks"}),"\n",(0,i.jsx)(n.p,{children:"This method is used to add a mapping of fragment IDs to their corresponding expression IDs.\r\nIt ensures that the bounding box calculations are accurate and up-to-date by updating the internal minimum and maximum vectors."}),"\n",(0,i.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBoxer = components.get(BoundingBoxer);\r\nconst fragmentIdMap: FRAGS.FragmentIdMap = {\r\n  '5991fa75-2eef-4825-90b3-85177f51a9c9': [123, 245, 389],\r\n  '3469077e-39bf-4fc9-b3e6-4a1d78ad52b0': [454, 587, 612],\r\n};\r\nboundingBoxer.addFragmentIdMap(fragmentIdMap);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"addmesh",children:"addMesh()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"addMesh"}),"(",(0,i.jsx)(n.code,{children:"mesh"}),", ",(0,i.jsx)(n.code,{children:"itemIDs"}),"?): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Adds a mesh to the BoundingBoxer and calculates the bounding box."}),"\n",(0,i.jsx)(n.h4,{id:"parameters-2",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"mesh"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"Mesh"}),"<",(0,i.jsx)(n.code,{children:"BufferGeometry"}),"<",(0,i.jsx)(n.code,{children:"NormalBufferAttributes"}),">, ",(0,i.jsx)(n.code,{children:"Material"})," | ",(0,i.jsx)(n.code,{children:"Material"}),"[], ",(0,i.jsx)(n.code,{children:"Object3DEventMap"}),"> | ",(0,i.jsx)(n.code,{children:"InstancedMesh"}),"<",(0,i.jsx)(n.code,{children:"BufferGeometry"}),"<",(0,i.jsx)(n.code,{children:"NormalBufferAttributes"}),">, ",(0,i.jsx)(n.code,{children:"Material"})," | ",(0,i.jsx)(n.code,{children:"Material"}),"[], ",(0,i.jsx)(n.code,{children:"InstancedMeshEventMap"}),"> | ",(0,i.jsx)(n.code,{children:"CurveMesh"}),"<",(0,i.jsx)(n.code,{children:"BufferGeometry"}),"<",(0,i.jsx)(n.code,{children:"NormalBufferAttributes"}),">, ",(0,i.jsx)(n.code,{children:"Material"})," | ",(0,i.jsx)(n.code,{children:"Material"}),"[]>"]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"itemIDs"}),"?"]}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"Iterable"}),"<",(0,i.jsx)(n.code,{children:"number"}),">"]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"An optional iterable of numbers representing the item IDs."})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"returns-2",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"void"})}),"\n",(0,i.jsx)(n.h4,{id:"remarks-2",children:"Remarks"}),"\n",(0,i.jsx)(n.p,{children:"This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.\r\nIf the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.\r\nIf the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs."}),"\n",(0,i.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBoxer = components.get(BoundingBoxer);\r\nboundingBoxer.addMesh(mesh);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"dispose",children:"dispose()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"dispose"}),"(): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable#dispose",children:"Disposable.dispose"})}),"\n",(0,i.jsx)(n.h4,{id:"returns-3",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"void"})}),"\n",(0,i.jsx)(n.h4,{id:"implementation-of-1",children:"Implementation of"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable",children:(0,i.jsx)(n.code,{children:"Disposable"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable#dispose",children:(0,i.jsx)(n.code,{children:"dispose"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"get",children:"get()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"get"}),"(): ",(0,i.jsx)(n.code,{children:"Box3"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Returns the bounding box of the calculated fragments."}),"\n",(0,i.jsx)(n.h4,{id:"returns-4",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Box3"})}),"\n",(0,i.jsx)(n.p,{children:"A new THREE.Box3 instance representing the bounding box."}),"\n",(0,i.jsx)(n.h4,{id:"remarks-3",children:"Remarks"}),"\n",(0,i.jsx)(n.p,{children:"This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.\r\nThe returned box represents the bounding box of the calculated fragments."}),"\n",(0,i.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBox = boundingBoxer.get();\r\nconsole.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"getmesh",children:"getMesh()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"getMesh"}),"(): ",(0,i.jsx)(n.code,{children:"Mesh"}),"<",(0,i.jsx)(n.code,{children:"BoxGeometry"}),", ",(0,i.jsx)(n.code,{children:"Material"})," | ",(0,i.jsx)(n.code,{children:"Material"}),"[], ",(0,i.jsx)(n.code,{children:"Object3DEventMap"}),">"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Returns a THREE.Mesh instance representing the bounding box."}),"\n",(0,i.jsx)(n.h4,{id:"returns-5",children:"Returns"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"Mesh"}),"<",(0,i.jsx)(n.code,{children:"BoxGeometry"}),", ",(0,i.jsx)(n.code,{children:"Material"})," | ",(0,i.jsx)(n.code,{children:"Material"}),"[], ",(0,i.jsx)(n.code,{children:"Object3DEventMap"}),">"]}),"\n",(0,i.jsx)(n.p,{children:"A new THREE.Mesh instance representing the bounding box."}),"\n",(0,i.jsx)(n.h4,{id:"remarks-4",children:"Remarks"}),"\n",(0,i.jsxs)(n.p,{children:["This method calculates the dimensions of the bounding box using the ",(0,i.jsx)(n.code,{children:"getDimensions"})," method.\r\nIt then creates a new THREE.BoxGeometry with the calculated dimensions.\r\nA new THREE.Mesh is created using the box geometry, and it is added to the ",(0,i.jsx)(n.code,{children:"_meshes"})," array.\r\nThe position of the mesh is set to the center of the bounding box."]}),"\n",(0,i.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBoxer = components.get(BoundingBoxer);\r\nboundingBoxer.add(fragmentsGroup);\r\nconst boundingBoxMesh = boundingBoxer.getMesh();\r\nscene.add(boundingBoxMesh);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"getsphere",children:"getSphere()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"getSphere"}),"(): ",(0,i.jsx)(n.code,{children:"Sphere"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Calculates and returns a sphere that encompasses the entire bounding box."}),"\n",(0,i.jsx)(n.h4,{id:"returns-6",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Sphere"})}),"\n",(0,i.jsx)(n.p,{children:"A new THREE.Sphere instance representing the calculated sphere."}),"\n",(0,i.jsx)(n.h4,{id:"remarks-5",children:"Remarks"}),"\n",(0,i.jsx)(n.p,{children:"This method calculates the center and radius of a sphere that encompasses the entire bounding box.\r\nThe center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.\r\nThe radius is calculated as the distance from the center to the minimum bound."}),"\n",(0,i.jsx)(n.h4,{id:"example-5",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBoxer = components.get(BoundingBoxer);\r\nboundingBoxer.add(fragmentsGroup);\r\nconst boundingSphere = boundingBoxer.getSphere();\r\nconsole.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"isconfigurable",children:"isConfigurable()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"isConfigurable"}),"(): ",(0,i.jsx)(n.code,{children:"this is Configurable<any, any>"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Whether is component is ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Configurable",children:"Configurable"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"returns-7",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"this is Configurable<any, any>"})}),"\n",(0,i.jsx)(n.h4,{id:"inherited-from",children:"Inherited from"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#isconfigurable",children:(0,i.jsx)(n.code,{children:"isConfigurable"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"isdisposeable",children:"isDisposeable()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"isDisposeable"}),"(): ",(0,i.jsx)(n.code,{children:"this is Disposable"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Whether is component is ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Disposable",children:"Disposable"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"returns-8",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"this is Disposable"})}),"\n",(0,i.jsx)(n.h4,{id:"inherited-from-1",children:"Inherited from"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#isdisposeable",children:(0,i.jsx)(n.code,{children:"isDisposeable"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"ishideable",children:"isHideable()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"isHideable"}),"(): ",(0,i.jsx)(n.code,{children:"this is Hideable"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Whether is component is ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Hideable",children:"Hideable"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"returns-9",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"this is Hideable"})}),"\n",(0,i.jsx)(n.h4,{id:"inherited-from-2",children:"Inherited from"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#ishideable",children:(0,i.jsx)(n.code,{children:"isHideable"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"isresizeable",children:"isResizeable()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"isResizeable"}),"(): ",(0,i.jsx)(n.code,{children:"this is Resizeable"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Whether is component is ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Resizeable",children:"Resizeable"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"returns-10",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"this is Resizeable"})}),"\n",(0,i.jsx)(n.h4,{id:"inherited-from-3",children:"Inherited from"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#isresizeable",children:(0,i.jsx)(n.code,{children:"isResizeable"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"isupdateable",children:"isUpdateable()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"isUpdateable"}),"(): ",(0,i.jsx)(n.code,{children:"this is Updateable"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Whether is component is ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/interfaces/Updateable",children:"Updateable"}),"."]}),"\n",(0,i.jsx)(n.h4,{id:"returns-11",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"this is Updateable"})}),"\n",(0,i.jsx)(n.h4,{id:"inherited-from-4",children:"Inherited from"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component",children:(0,i.jsx)(n.code,{children:"Component"})})," . ",(0,i.jsx)(n.a,{href:"/3.0.x/api/@thatopen/components/classes/Component#isupdateable",children:(0,i.jsx)(n.code,{children:"isUpdateable"})})]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"reset",children:"reset()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"reset"}),"(): ",(0,i.jsx)(n.code,{children:"void"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.\r\nThis method is used to prepare the BoundingBoxer for a new set of fragments."}),"\n",(0,i.jsx)(n.h4,{id:"returns-12",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"void"})}),"\n",(0,i.jsx)(n.h4,{id:"remarks-6",children:"Remarks"}),"\n",(0,i.jsx)(n.p,{children:"This method is called when a new set of fragments is added to the BoundingBoxer.\r\nIt ensures that the bounding box calculations are accurate and up-to-date."}),"\n",(0,i.jsx)(n.h4,{id:"example-6",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const boundingBoxer = components.get(BoundingBoxer);\r\nboundingBoxer.add(fragmentsGroup);\r\n// ...\r\nboundingBoxer.reset();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"getbounds",children:"getBounds()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"static"})," ",(0,i.jsx)(n.strong,{children:"getBounds"}),"(",(0,i.jsx)(n.code,{children:"points"}),", ",(0,i.jsx)(n.code,{children:"min"}),"?, ",(0,i.jsx)(n.code,{children:"max"}),"?): ",(0,i.jsx)(n.code,{children:"Box3"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A static method to calculate the bounding box of a set of points."}),"\n",(0,i.jsx)(n.h4,{id:"parameters-3",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"points"})}),(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"Vector3"}),"[]"]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"An array of THREE.Vector3 representing the points."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"min"}),"?"]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"Vector3"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated."})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsxs)(n.td,{style:{textAlign:"left"},children:[(0,i.jsx)(n.code,{children:"max"}),"?"]}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"Vector3"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated."})]})]})]}),"\n",(0,i.jsx)(n.h4,{id:"returns-13",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Box3"})}),"\n",(0,i.jsx)(n.p,{children:"A THREE.Box3 representing the bounding box of the given points."}),"\n",(0,i.jsx)(n.h4,{id:"remarks-7",children:"Remarks"}),"\n",(0,i.jsxs)(n.p,{children:["This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.\r\nIf the ",(0,i.jsx)(n.code,{children:"min"})," or ",(0,i.jsx)(n.code,{children:"max"})," parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity."]}),"\n",(0,i.jsx)(n.h4,{id:"example-7",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const points = [\r\n  new THREE.Vector3(1, 2, 3),\r\n  new THREE.Vector3(4, 5, 6),\r\n  new THREE.Vector3(7, 8, 9),\r\n];\n\nconst bbox = BoundingBoxer.getBounds(points);\r\nconsole.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"getdimensions",children:"getDimensions()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"static"})," ",(0,i.jsx)(n.strong,{children:"getDimensions"}),"(",(0,i.jsx)(n.code,{children:"bbox"}),"): ",(0,i.jsx)(n.code,{children:"object"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A static method to calculate the dimensions of a given bounding box."}),"\n",(0,i.jsx)(n.h4,{id:"parameters-4",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"bbox"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"Box3"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"The bounding box to calculate the dimensions for."})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"returns-14",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"object"})}),"\n",(0,i.jsx)(n.p,{children:"An object containing the width, height, depth, and center of the bounding box."}),"\n",(0,i.jsx)(n.h5,{id:"center",children:"center"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"center"}),": ",(0,i.jsx)(n.code,{children:"Vector3"})]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"depth",children:"depth"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"depth"}),": ",(0,i.jsx)(n.code,{children:"number"})]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"height",children:"height"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"height"}),": ",(0,i.jsx)(n.code,{children:"number"})]}),"\n"]}),"\n",(0,i.jsx)(n.h5,{id:"width",children:"width"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"width"}),": ",(0,i.jsx)(n.code,{children:"number"})]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h3,{id:"newbound",children:"newBound()"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"static"})," ",(0,i.jsx)(n.strong,{children:"newBound"}),"(",(0,i.jsx)(n.code,{children:"positive"}),"): ",(0,i.jsx)(n.code,{children:"Vector3"})]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"A static method to create a new bounding box boundary."}),"\n",(0,i.jsx)(n.h4,{id:"parameters-5",children:"Parameters"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Parameter"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Type"}),(0,i.jsx)(n.th,{style:{textAlign:"left"},children:"Description"})]})}),(0,i.jsx)(n.tbody,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"positive"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:(0,i.jsx)(n.code,{children:"boolean"})}),(0,i.jsx)(n.td,{style:{textAlign:"left"},children:"A boolean indicating whether to create a boundary for positive or negative values."})]})})]}),"\n",(0,i.jsx)(n.h4,{id:"returns-15",children:"Returns"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.code,{children:"Vector3"})}),"\n",(0,i.jsx)(n.p,{children:"A new THREE.Vector3 representing the boundary."}),"\n",(0,i.jsx)(n.h4,{id:"remarks-8",children:"Remarks"}),"\n",(0,i.jsxs)(n.p,{children:["This method is used to create a new boundary for calculating bounding boxes.\r\nIt sets the x, y, and z components of the returned vector to positive or negative infinity,\r\ndepending on the value of the ",(0,i.jsx)(n.code,{children:"positive"})," parameter."]}),"\n",(0,i.jsx)(n.h4,{id:"example-8",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const positiveBound = BoundingBoxer.newBound(true);\r\nconsole.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }\n\nconst negativeBound = BoundingBoxer.newBound(false);\r\nconsole.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }\n"})})]})}function a(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>l});var i=s(6540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);